# This file was generated. Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

type CommunityCreated {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    communityId: BigInt!
    id: Bytes!
    ipfsMetadata: String!
    owner: Bytes!
    stakingRequirement: BigInt!
    transactionHash: Bytes!
}

type MemberJoinedCommunity {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    communityId: BigInt!
    id: Bytes!
    member: Bytes!
    transactionHash: Bytes!
}

type OfferAccepted {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    communityId: BigInt!
    id: Bytes!
    member: Bytes!
    offerId: BigInt!
    transactionHash: Bytes!
}

type OfferCreated {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    communityId: BigInt!
    id: Bytes!
    metadata: String!
    offerId: BigInt!
    owner: Bytes!
    reputationRequirement: BigInt!
    stakingRequirement: BigInt!
    transactionHash: Bytes!
}

type OwnershipTransferred {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    newOwner: Bytes!
    previousOwner: Bytes!
    transactionHash: Bytes!
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    communityCreated(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CommunityCreated
    communityCreateds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: CommunityCreated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: CommunityCreated_filter
    ): [CommunityCreated!]!
    memberJoinedCommunities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MemberJoinedCommunity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MemberJoinedCommunity_filter
    ): [MemberJoinedCommunity!]!
    memberJoinedCommunity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MemberJoinedCommunity
    offerAccepted(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OfferAccepted
    offerAccepteds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OfferAccepted_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OfferAccepted_filter
    ): [OfferAccepted!]!
    offerCreated(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OfferCreated
    offerCreateds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OfferCreated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OfferCreated_filter
    ): [OfferCreated!]!
    ownershipTransferred(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OwnershipTransferred
    ownershipTransferreds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OwnershipTransferred_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OwnershipTransferred_filter
    ): [OwnershipTransferred!]!
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    communityCreated(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CommunityCreated
    communityCreateds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: CommunityCreated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: CommunityCreated_filter
    ): [CommunityCreated!]!
    memberJoinedCommunities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MemberJoinedCommunity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MemberJoinedCommunity_filter
    ): [MemberJoinedCommunity!]!
    memberJoinedCommunity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MemberJoinedCommunity
    offerAccepted(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OfferAccepted
    offerAccepteds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OfferAccepted_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OfferAccepted_filter
    ): [OfferAccepted!]!
    offerCreated(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OfferCreated
    offerCreateds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OfferCreated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OfferCreated_filter
    ): [OfferCreated!]!
    ownershipTransferred(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OwnershipTransferred
    ownershipTransferreds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OwnershipTransferred_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OwnershipTransferred_filter
    ): [OwnershipTransferred!]!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
    "Integer representation of the timestamp stored in blocks for the chain"
    timestamp: Int
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

enum CommunityCreated_orderBy {
    blockNumber
    blockTimestamp
    communityId
    id
    ipfsMetadata
    owner
    stakingRequirement
    transactionHash
}

enum MemberJoinedCommunity_orderBy {
    blockNumber
    blockTimestamp
    communityId
    id
    member
    transactionHash
}

enum OfferAccepted_orderBy {
    blockNumber
    blockTimestamp
    communityId
    id
    member
    offerId
    transactionHash
}

enum OfferCreated_orderBy {
    blockNumber
    blockTimestamp
    communityId
    id
    metadata
    offerId
    owner
    reputationRequirement
    stakingRequirement
    transactionHash
}

"Defines the order direction, either ascending or descending"
enum OrderDirection {
    asc
    desc
}

enum OwnershipTransferred_orderBy {
    blockNumber
    blockTimestamp
    id
    newOwner
    previousOwner
    transactionHash
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

scalar BigDecimal

scalar BigInt

scalar Bytes

"""

8 bytes signed integer
"""
scalar Int8

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

input CommunityCreated_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [CommunityCreated_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    communityId: BigInt
    communityId_gt: BigInt
    communityId_gte: BigInt
    communityId_in: [BigInt!]
    communityId_lt: BigInt
    communityId_lte: BigInt
    communityId_not: BigInt
    communityId_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    ipfsMetadata: String
    ipfsMetadata_contains: String
    ipfsMetadata_contains_nocase: String
    ipfsMetadata_ends_with: String
    ipfsMetadata_ends_with_nocase: String
    ipfsMetadata_gt: String
    ipfsMetadata_gte: String
    ipfsMetadata_in: [String!]
    ipfsMetadata_lt: String
    ipfsMetadata_lte: String
    ipfsMetadata_not: String
    ipfsMetadata_not_contains: String
    ipfsMetadata_not_contains_nocase: String
    ipfsMetadata_not_ends_with: String
    ipfsMetadata_not_ends_with_nocase: String
    ipfsMetadata_not_in: [String!]
    ipfsMetadata_not_starts_with: String
    ipfsMetadata_not_starts_with_nocase: String
    ipfsMetadata_starts_with: String
    ipfsMetadata_starts_with_nocase: String
    or: [CommunityCreated_filter]
    owner: Bytes
    owner_contains: Bytes
    owner_gt: Bytes
    owner_gte: Bytes
    owner_in: [Bytes!]
    owner_lt: Bytes
    owner_lte: Bytes
    owner_not: Bytes
    owner_not_contains: Bytes
    owner_not_in: [Bytes!]
    stakingRequirement: BigInt
    stakingRequirement_gt: BigInt
    stakingRequirement_gte: BigInt
    stakingRequirement_in: [BigInt!]
    stakingRequirement_lt: BigInt
    stakingRequirement_lte: BigInt
    stakingRequirement_not: BigInt
    stakingRequirement_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input MemberJoinedCommunity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [MemberJoinedCommunity_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    communityId: BigInt
    communityId_gt: BigInt
    communityId_gte: BigInt
    communityId_in: [BigInt!]
    communityId_lt: BigInt
    communityId_lte: BigInt
    communityId_not: BigInt
    communityId_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    member: Bytes
    member_contains: Bytes
    member_gt: Bytes
    member_gte: Bytes
    member_in: [Bytes!]
    member_lt: Bytes
    member_lte: Bytes
    member_not: Bytes
    member_not_contains: Bytes
    member_not_in: [Bytes!]
    or: [MemberJoinedCommunity_filter]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input OfferAccepted_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [OfferAccepted_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    communityId: BigInt
    communityId_gt: BigInt
    communityId_gte: BigInt
    communityId_in: [BigInt!]
    communityId_lt: BigInt
    communityId_lte: BigInt
    communityId_not: BigInt
    communityId_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    member: Bytes
    member_contains: Bytes
    member_gt: Bytes
    member_gte: Bytes
    member_in: [Bytes!]
    member_lt: Bytes
    member_lte: Bytes
    member_not: Bytes
    member_not_contains: Bytes
    member_not_in: [Bytes!]
    offerId: BigInt
    offerId_gt: BigInt
    offerId_gte: BigInt
    offerId_in: [BigInt!]
    offerId_lt: BigInt
    offerId_lte: BigInt
    offerId_not: BigInt
    offerId_not_in: [BigInt!]
    or: [OfferAccepted_filter]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input OfferCreated_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [OfferCreated_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    communityId: BigInt
    communityId_gt: BigInt
    communityId_gte: BigInt
    communityId_in: [BigInt!]
    communityId_lt: BigInt
    communityId_lte: BigInt
    communityId_not: BigInt
    communityId_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    metadata: String
    metadata_contains: String
    metadata_contains_nocase: String
    metadata_ends_with: String
    metadata_ends_with_nocase: String
    metadata_gt: String
    metadata_gte: String
    metadata_in: [String!]
    metadata_lt: String
    metadata_lte: String
    metadata_not: String
    metadata_not_contains: String
    metadata_not_contains_nocase: String
    metadata_not_ends_with: String
    metadata_not_ends_with_nocase: String
    metadata_not_in: [String!]
    metadata_not_starts_with: String
    metadata_not_starts_with_nocase: String
    metadata_starts_with: String
    metadata_starts_with_nocase: String
    offerId: BigInt
    offerId_gt: BigInt
    offerId_gte: BigInt
    offerId_in: [BigInt!]
    offerId_lt: BigInt
    offerId_lte: BigInt
    offerId_not: BigInt
    offerId_not_in: [BigInt!]
    or: [OfferCreated_filter]
    owner: Bytes
    owner_contains: Bytes
    owner_gt: Bytes
    owner_gte: Bytes
    owner_in: [Bytes!]
    owner_lt: Bytes
    owner_lte: Bytes
    owner_not: Bytes
    owner_not_contains: Bytes
    owner_not_in: [Bytes!]
    reputationRequirement: BigInt
    reputationRequirement_gt: BigInt
    reputationRequirement_gte: BigInt
    reputationRequirement_in: [BigInt!]
    reputationRequirement_lt: BigInt
    reputationRequirement_lte: BigInt
    reputationRequirement_not: BigInt
    reputationRequirement_not_in: [BigInt!]
    stakingRequirement: BigInt
    stakingRequirement_gt: BigInt
    stakingRequirement_gte: BigInt
    stakingRequirement_in: [BigInt!]
    stakingRequirement_lt: BigInt
    stakingRequirement_lte: BigInt
    stakingRequirement_not: BigInt
    stakingRequirement_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input OwnershipTransferred_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [OwnershipTransferred_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    newOwner: Bytes
    newOwner_contains: Bytes
    newOwner_gt: Bytes
    newOwner_gte: Bytes
    newOwner_in: [Bytes!]
    newOwner_lt: Bytes
    newOwner_lte: Bytes
    newOwner_not: Bytes
    newOwner_not_contains: Bytes
    newOwner_not_in: [Bytes!]
    or: [OwnershipTransferred_filter]
    previousOwner: Bytes
    previousOwner_contains: Bytes
    previousOwner_gt: Bytes
    previousOwner_gte: Bytes
    previousOwner_in: [Bytes!]
    previousOwner_lt: Bytes
    previousOwner_lte: Bytes
    previousOwner_not: Bytes
    previousOwner_not_contains: Bytes
    previousOwner_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}
